import { test } from 'node:test';
import assert from 'node:assert';
import fs from 'fs';
import path from 'path';

function normalizeString(string) {
    return string.normalize();
}

test('CityList', async (t) => {
    await t.test('cities.json', async (t) => {
        await t.test('should have at least one entry', () => {
            const cities = JSON.parse(fs.readFileSync('cities/cities.json'));
            assert(Object.keys(cities).length > 0, 'Cities list should not be empty');
        });

        await t.test('should contain only city objects', () => {
            const cities = JSON.parse(fs.readFileSync('cities/cities.json'));
            const keys = Object.keys(cities);
            
            for (const key of keys) {
                const city = cities[key];
                assert(city.id !== undefined, `City "${key}" requires property "id"`);
                assert(city.label !== undefined, `City "${key}" requires property "label"`);
                assert(Object.keys(city).length <= 3, 'Cities should only have the properties id, label and an optional position');
            }
        });

        await t.test('should contain valid positions', () => {
            const cities = JSON.parse(fs.readFileSync('cities/cities.json'));
            for (const city of Object.values(cities)) {
                if (city.position) {
                    assert(Array.isArray(city.position), 'Position should be an array');
                    assert(city.position.length === 2, 'Position should have exactly 2 coordinates');
                    assert(typeof city.position[0] === 'number', 'First coordinate should be a number');
                    assert(city.position[0] >= -180 && city.position[0] <= 180, 'First coordinate should be between -180 and 180');
                    assert(typeof city.position[1] === 'number', 'Second coordinate should be a number');
                    assert(city.position[1] >= -180 && city.position[1] <= 180, 'Second coordinate should be between -180 and 180');
                }
            }
        });

        await t.test('should have an entry for each city.json file', () => {
            const dirContent = fs.readdirSync('cities');
            const cities = JSON.parse(fs.readFileSync('cities/cities.json'));
            const regexp = /json$/;

            const cityNames = Object.keys(cities).map(normalizeString);

            const missingCities = dirContent
                .filter(fileName => regexp.test(fileName) && fileName !== 'cities.json')
                .map(fileName => {
                    const cityName = path.basename(fileName, '.json');
                    return normalizeString(cityName);
                })
                .filter(cityName => !cityNames.includes(cityName));

            assert.deepStrictEqual(missingCities, [], `Missing cities in cities.json: ${missingCities.join(', ')}`);
        });

        await t.test('should have a city specific json file for each city in the list', () => {
            const cities = JSON.parse(fs.readFileSync('cities/cities.json'));
            const keys = Object.keys(cities);

            for (const key of keys) {
                const city = cities[key];
                const cityPath = 'cities/' + city.id + '.json';
                const cityGeoJson = fs.readFileSync(cityPath);
                assert(JSON.parse(cityGeoJson).type !== undefined, `City ${city.id} should have a valid GeoJSON type`);
            }
        });

        await t.test('should only have entries where the key and the id match', () => {
            const cities = JSON.parse(fs.readFileSync('cities/cities.json'));
            const keys = Object.keys(cities);

            for (const key of keys) {
                const city = cities[key];
                assert.strictEqual(key, city.id, 'Key and id do not match');
            }
        });
    });
}); 